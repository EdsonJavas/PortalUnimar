{
  "version": 3,
  "sources": ["../../hono/dist/helper/factory/index.js", "../../hono/dist/http-exception.js", "../../@getmocha/users-service/dist/backend.js"],
  "sourcesContent": ["// src/helper/factory/index.ts\r\nimport { Hono } from \"../../hono.js\";\r\nvar Factory = class {\r\n  initApp;\r\n  #defaultAppOptions;\r\n  constructor(init) {\r\n    this.initApp = init?.initApp;\r\n    this.#defaultAppOptions = init?.defaultAppOptions;\r\n  }\r\n  createApp = (options) => {\r\n    const app = new Hono(\r\n      options && this.#defaultAppOptions ? { ...this.#defaultAppOptions, ...options } : options ?? this.#defaultAppOptions\r\n    );\r\n    if (this.initApp) {\r\n      this.initApp(app);\r\n    }\r\n    return app;\r\n  };\r\n  createMiddleware = (middleware) => middleware;\r\n  createHandlers = (...handlers) => {\r\n    return handlers.filter((handler) => handler !== void 0);\r\n  };\r\n};\r\nvar createFactory = (init) => new Factory(init);\r\nvar createMiddleware = (middleware) => middleware;\r\nexport {\r\n  Factory,\r\n  createFactory,\r\n  createMiddleware\r\n};\r\n", "// src/http-exception.ts\r\nvar HTTPException = class extends Error {\r\n  res;\r\n  status;\r\n  constructor(status = 500, options) {\r\n    super(options?.message, { cause: options?.cause });\r\n    this.res = options?.res;\r\n    this.status = status;\r\n  }\r\n  getResponse() {\r\n    if (this.res) {\r\n      const newResponse = new Response(this.res.body, {\r\n        status: this.status,\r\n        headers: this.res.headers\r\n      });\r\n      return newResponse;\r\n    }\r\n    return new Response(this.message, {\r\n      status: this.status\r\n    });\r\n  }\r\n};\r\nexport {\r\n  HTTPException\r\n};\r\n", "/// <reference types=\"hono\" />\r\nimport { getCookie } from 'hono/cookie';\r\nimport { createMiddleware } from 'hono/factory';\r\nimport { HTTPException } from 'hono/http-exception';\r\nexport const DEFAULT_MOCHA_USERS_SERVICE_API_URL = 'https://getmocha.com/u';\r\nexport const MOCHA_SESSION_TOKEN_COOKIE_NAME = 'mocha_session_token';\r\nexport const SUPPORTED_OAUTH_PROVIDERS = ['google'];\r\n/**\r\n * Fetch the OAuth redirect URL from the Mocha Users Service.\r\n * @param provider - The OAuth provider to use (currently only \"google\" is supported)\r\n * @param options - Configuration options including API key and optional API URL\r\n * @returns The redirect URL to initiate the OAuth flow\r\n */\r\nexport async function getOAuthRedirectUrl(provider, options) {\r\n    if (!SUPPORTED_OAUTH_PROVIDERS.includes(provider)) {\r\n        throw new Error(`Unsupported OAuth provider: ${provider}`);\r\n    }\r\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\r\n    const response = await fetch(`${apiUrl}/oauth/${provider}/redirect_url`, {\r\n        method: 'GET',\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            'x-api-key': options.apiKey,\r\n        },\r\n    });\r\n    if (!response.ok) {\r\n        throw new Error(`Failed to get redirect URL for provider ${provider}: ${response.statusText}`);\r\n    }\r\n    const { redirect_url } = await response.json();\r\n    return redirect_url;\r\n}\r\n/**\r\n * Exchanges a code for a session token using the Mocha Users Service.\r\n * @param code - The OAuth code received after successful authentication\r\n * @param options - Configuration options including API key and optional API URL\r\n * @returns The session token to use for authenticated requests\r\n */\r\nexport async function exchangeCodeForSessionToken(code, options) {\r\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\r\n    const response = await fetch(`${apiUrl}/sessions`, {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            'x-api-key': options.apiKey,\r\n        },\r\n        body: JSON.stringify({ code }),\r\n    });\r\n    if (!response.ok) {\r\n        throw new Error(`Failed to exchange code for session token: ${response.statusText}`);\r\n    }\r\n    const { session_token } = await response.json();\r\n    return session_token;\r\n}\r\n/**\r\n * Fetch the current user by their session token from the Mocha Users Service.\r\n * @param sessionToken - The session token obtained from exchangeCodeForSessionToken\r\n * @param options - Configuration options including API key and optional API URL\r\n * @returns The user object or null if the session is invalid\r\n */\r\nexport async function getCurrentUser(sessionToken, options) {\r\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\r\n    try {\r\n        const response = await fetch(`${apiUrl}/users/me`, {\r\n            method: 'GET',\r\n            headers: {\r\n                Authorization: `Bearer ${sessionToken}`,\r\n                'x-api-key': options.apiKey,\r\n            },\r\n        });\r\n        if (!response.ok) {\r\n            return null;\r\n        }\r\n        const { data: user } = await response.json();\r\n        return user;\r\n    }\r\n    catch (error) {\r\n        console.error('Error validating session:', error);\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Delete the current session in the Mocha Users Service when logging out.\r\n * @param sessionToken - The users session token from their cookie.\r\n * @param options - Configuration options including API key and optional API URL\r\n */\r\nexport async function deleteSession(sessionToken, options) {\r\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\r\n    try {\r\n        await fetch(`${apiUrl}/sessions`, {\r\n            method: 'DELETE',\r\n            headers: {\r\n                Authorization: `Bearer ${sessionToken}`,\r\n                'x-api-key': options.apiKey,\r\n            },\r\n        });\r\n    }\r\n    catch (error) {\r\n        console.error('Error deleting session:', error);\r\n    }\r\n}\r\n/**\r\n * Hono middleware that authenticates requests against the Mocha Users Service.\r\n *\r\n * This middleware requests the current user using the session token stored in\r\n * cookies. If the request fails to return a valid user object, the middleware\r\n * throws an HTTPException with status 401. On success, it sets the authenticated\r\n * user in the Hono context for use in subsequent route handlers.\r\n *\r\n * Use this to protect routes and load the current user.\r\n *\r\n * @throws {HTTPException} 401 - When session token is invalid or not provided\r\n *\r\n * @example\r\n *\r\n * // Fetch the authenticated user's todos.\r\n * // Doesn't execute if the user is not authenticated.\r\n * app.get(\"/api/todos\", authMiddleware, async (c) => {\r\n *   const user = c.get(\"user\");\r\n *\r\n *   const { results } = await c.env.DB.prepare(\r\n *     \"SELECT * FROM todos WHERE user_id = ? ORDER BY created_at DESC\"\r\n *   )\r\n *     .bind(user.id)\r\n *     .all();\r\n *\r\n *   return c.json(results);\r\n * });\r\n */\r\nexport const authMiddleware = createMiddleware(async (c, next) => {\r\n    const sessionToken = getCookie(c, MOCHA_SESSION_TOKEN_COOKIE_NAME);\r\n    if (typeof sessionToken !== 'string') {\r\n        return c.json({ error: 'Unauthorized' }, 401);\r\n    }\r\n    const options = {\r\n        apiUrl: c.env.MOCHA_USERS_SERVICE_API_URL,\r\n        apiKey: c.env.MOCHA_USERS_SERVICE_API_KEY,\r\n    };\r\n    const user = await getCurrentUser(sessionToken, options);\r\n    if (!user) {\r\n        throw new HTTPException(401, { message: 'Invalid session token' });\r\n    }\r\n    c.set('user', user);\r\n    await next();\r\n});\r\n"],
  "mappings": ";;;;;;;;AAwBA,IAAI,mBAAmB,CAAC,eAAe;;;ACvBvC,IAAI,gBAAgB,cAAc,MAAM;AAAA,EACtC;AAAA,EACA;AAAA,EACA,YAAY,SAAS,KAAK,SAAS;AACjC,UAAM,SAAS,SAAS,EAAE,OAAO,SAAS,MAAM,CAAC;AACjD,SAAK,MAAM,SAAS;AACpB,SAAK,SAAS;AAAA,EAChB;AAAA,EACA,cAAc;AACZ,QAAI,KAAK,KAAK;AACZ,YAAM,cAAc,IAAI,SAAS,KAAK,IAAI,MAAM;AAAA,QAC9C,QAAQ,KAAK;AAAA,QACb,SAAS,KAAK,IAAI;AAAA,MACpB,CAAC;AACD,aAAO;AAAA,IACT;AACA,WAAO,IAAI,SAAS,KAAK,SAAS;AAAA,MAChC,QAAQ,KAAK;AAAA,IACf,CAAC;AAAA,EACH;AACF;;;ACjBO,IAAM,sCAAsC;AAC5C,IAAM,kCAAkC;AACxC,IAAM,4BAA4B,CAAC,QAAQ;AAOlD,eAAsB,oBAAoB,UAAU,SAAS;AACzD,MAAI,CAAC,0BAA0B,SAAS,QAAQ,GAAG;AAC/C,UAAM,IAAI,MAAM,+BAA+B,QAAQ,EAAE;AAAA,EAC7D;AACA,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,WAAW,MAAM,MAAM,GAAG,MAAM,UAAU,QAAQ,iBAAiB;AAAA,IACrE,QAAQ;AAAA,IACR,SAAS;AAAA,MACL,gBAAgB;AAAA,MAChB,aAAa,QAAQ;AAAA,IACzB;AAAA,EACJ,CAAC;AACD,MAAI,CAAC,SAAS,IAAI;AACd,UAAM,IAAI,MAAM,2CAA2C,QAAQ,KAAK,SAAS,UAAU,EAAE;AAAA,EACjG;AACA,QAAM,EAAE,aAAa,IAAI,MAAM,SAAS,KAAK;AAC7C,SAAO;AACX;AAOA,eAAsB,4BAA4B,MAAM,SAAS;AAC7D,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,WAAW,MAAM,MAAM,GAAG,MAAM,aAAa;AAAA,IAC/C,QAAQ;AAAA,IACR,SAAS;AAAA,MACL,gBAAgB;AAAA,MAChB,aAAa,QAAQ;AAAA,IACzB;AAAA,IACA,MAAM,KAAK,UAAU,EAAE,KAAK,CAAC;AAAA,EACjC,CAAC;AACD,MAAI,CAAC,SAAS,IAAI;AACd,UAAM,IAAI,MAAM,8CAA8C,SAAS,UAAU,EAAE;AAAA,EACvF;AACA,QAAM,EAAE,cAAc,IAAI,MAAM,SAAS,KAAK;AAC9C,SAAO;AACX;AAOA,eAAsB,eAAe,cAAc,SAAS;AACxD,QAAM,SAAS,QAAQ,UAAU;AACjC,MAAI;AACA,UAAM,WAAW,MAAM,MAAM,GAAG,MAAM,aAAa;AAAA,MAC/C,QAAQ;AAAA,MACR,SAAS;AAAA,QACL,eAAe,UAAU,YAAY;AAAA,QACrC,aAAa,QAAQ;AAAA,MACzB;AAAA,IACJ,CAAC;AACD,QAAI,CAAC,SAAS,IAAI;AACd,aAAO;AAAA,IACX;AACA,UAAM,EAAE,MAAM,KAAK,IAAI,MAAM,SAAS,KAAK;AAC3C,WAAO;AAAA,EACX,SACO,OAAO;AACV,YAAQ,MAAM,6BAA6B,KAAK;AAChD,WAAO;AAAA,EACX;AACJ;AAMA,eAAsB,cAAc,cAAc,SAAS;AACvD,QAAM,SAAS,QAAQ,UAAU;AACjC,MAAI;AACA,UAAM,MAAM,GAAG,MAAM,aAAa;AAAA,MAC9B,QAAQ;AAAA,MACR,SAAS;AAAA,QACL,eAAe,UAAU,YAAY;AAAA,QACrC,aAAa,QAAQ;AAAA,MACzB;AAAA,IACJ,CAAC;AAAA,EACL,SACO,OAAO;AACV,YAAQ,MAAM,2BAA2B,KAAK;AAAA,EAClD;AACJ;AA6BO,IAAM,iBAAiB,iBAAiB,OAAO,GAAG,SAAS;AAC9D,QAAM,eAAe,UAAU,GAAG,+BAA+B;AACjE,MAAI,OAAO,iBAAiB,UAAU;AAClC,WAAO,EAAE,KAAK,EAAE,OAAO,eAAe,GAAG,GAAG;AAAA,EAChD;AACA,QAAM,UAAU;AAAA,IACZ,QAAQ,EAAE,IAAI;AAAA,IACd,QAAQ,EAAE,IAAI;AAAA,EAClB;AACA,QAAM,OAAO,MAAM,eAAe,cAAc,OAAO;AACvD,MAAI,CAAC,MAAM;AACP,UAAM,IAAI,cAAc,KAAK,EAAE,SAAS,wBAAwB,CAAC;AAAA,EACrE;AACA,IAAE,IAAI,QAAQ,IAAI;AAClB,QAAM,KAAK;AACf,CAAC;",
  "names": []
}
