{
  "version": 3,
  "sources": ["../../hono/dist/helper/factory/index.js", "../../hono/dist/http-exception.js", "../../@getmocha/users-service/dist/backend.js"],
  "sourcesContent": ["// src/helper/factory/index.ts\nimport { Hono } from \"../../hono.js\";\nvar Factory = class {\n  initApp;\n  #defaultAppOptions;\n  constructor(init) {\n    this.initApp = init?.initApp;\n    this.#defaultAppOptions = init?.defaultAppOptions;\n  }\n  createApp = (options) => {\n    const app = new Hono(\n      options && this.#defaultAppOptions ? { ...this.#defaultAppOptions, ...options } : options ?? this.#defaultAppOptions\n    );\n    if (this.initApp) {\n      this.initApp(app);\n    }\n    return app;\n  };\n  createMiddleware = (middleware) => middleware;\n  createHandlers = (...handlers) => {\n    return handlers.filter((handler) => handler !== void 0);\n  };\n};\nvar createFactory = (init) => new Factory(init);\nvar createMiddleware = (middleware) => middleware;\nexport {\n  Factory,\n  createFactory,\n  createMiddleware\n};\n", "// src/http-exception.ts\nvar HTTPException = class extends Error {\n  res;\n  status;\n  constructor(status = 500, options) {\n    super(options?.message, { cause: options?.cause });\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      const newResponse = new Response(this.res.body, {\n        status: this.status,\n        headers: this.res.headers\n      });\n      return newResponse;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n", "/// <reference types=\"hono\" />\nimport { getCookie } from 'hono/cookie';\nimport { createMiddleware } from 'hono/factory';\nimport { HTTPException } from 'hono/http-exception';\nexport const DEFAULT_MOCHA_USERS_SERVICE_API_URL = 'https://getmocha.com/u';\nexport const MOCHA_SESSION_TOKEN_COOKIE_NAME = 'mocha_session_token';\nexport const SUPPORTED_OAUTH_PROVIDERS = ['google'];\n/**\n * Fetch the OAuth redirect URL from the Mocha Users Service.\n * @param provider - The OAuth provider to use (currently only \"google\" is supported)\n * @param options - Configuration options including API key and optional API URL\n * @returns The redirect URL to initiate the OAuth flow\n */\nexport async function getOAuthRedirectUrl(provider, options) {\n    if (!SUPPORTED_OAUTH_PROVIDERS.includes(provider)) {\n        throw new Error(`Unsupported OAuth provider: ${provider}`);\n    }\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\n    const response = await fetch(`${apiUrl}/oauth/${provider}/redirect_url`, {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json',\n            'x-api-key': options.apiKey,\n        },\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to get redirect URL for provider ${provider}: ${response.statusText}`);\n    }\n    const { redirect_url } = await response.json();\n    return redirect_url;\n}\n/**\n * Exchanges a code for a session token using the Mocha Users Service.\n * @param code - The OAuth code received after successful authentication\n * @param options - Configuration options including API key and optional API URL\n * @returns The session token to use for authenticated requests\n */\nexport async function exchangeCodeForSessionToken(code, options) {\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\n    const response = await fetch(`${apiUrl}/sessions`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'x-api-key': options.apiKey,\n        },\n        body: JSON.stringify({ code }),\n    });\n    if (!response.ok) {\n        throw new Error(`Failed to exchange code for session token: ${response.statusText}`);\n    }\n    const { session_token } = await response.json();\n    return session_token;\n}\n/**\n * Fetch the current user by their session token from the Mocha Users Service.\n * @param sessionToken - The session token obtained from exchangeCodeForSessionToken\n * @param options - Configuration options including API key and optional API URL\n * @returns The user object or null if the session is invalid\n */\nexport async function getCurrentUser(sessionToken, options) {\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\n    try {\n        const response = await fetch(`${apiUrl}/users/me`, {\n            method: 'GET',\n            headers: {\n                Authorization: `Bearer ${sessionToken}`,\n                'x-api-key': options.apiKey,\n            },\n        });\n        if (!response.ok) {\n            return null;\n        }\n        const { data: user } = await response.json();\n        return user;\n    }\n    catch (error) {\n        console.error('Error validating session:', error);\n        return null;\n    }\n}\n/**\n * Delete the current session in the Mocha Users Service when logging out.\n * @param sessionToken - The users session token from their cookie.\n * @param options - Configuration options including API key and optional API URL\n */\nexport async function deleteSession(sessionToken, options) {\n    const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;\n    try {\n        await fetch(`${apiUrl}/sessions`, {\n            method: 'DELETE',\n            headers: {\n                Authorization: `Bearer ${sessionToken}`,\n                'x-api-key': options.apiKey,\n            },\n        });\n    }\n    catch (error) {\n        console.error('Error deleting session:', error);\n    }\n}\n/**\n * Hono middleware that authenticates requests against the Mocha Users Service.\n *\n * This middleware requests the current user using the session token stored in\n * cookies. If the request fails to return a valid user object, the middleware\n * throws an HTTPException with status 401. On success, it sets the authenticated\n * user in the Hono context for use in subsequent route handlers.\n *\n * Use this to protect routes and load the current user.\n *\n * @throws {HTTPException} 401 - When session token is invalid or not provided\n *\n * @example\n *\n * // Fetch the authenticated user's todos.\n * // Doesn't execute if the user is not authenticated.\n * app.get(\"/api/todos\", authMiddleware, async (c) => {\n *   const user = c.get(\"user\");\n *\n *   const { results } = await c.env.DB.prepare(\n *     \"SELECT * FROM todos WHERE user_id = ? ORDER BY created_at DESC\"\n *   )\n *     .bind(user.id)\n *     .all();\n *\n *   return c.json(results);\n * });\n */\nexport const authMiddleware = createMiddleware(async (c, next) => {\n    const sessionToken = getCookie(c, MOCHA_SESSION_TOKEN_COOKIE_NAME);\n    if (typeof sessionToken !== 'string') {\n        return c.json({ error: 'Unauthorized' }, 401);\n    }\n    const options = {\n        apiUrl: c.env.MOCHA_USERS_SERVICE_API_URL,\n        apiKey: c.env.MOCHA_USERS_SERVICE_API_KEY,\n    };\n    const user = await getCurrentUser(sessionToken, options);\n    if (!user) {\n        throw new HTTPException(401, { message: 'Invalid session token' });\n    }\n    c.set('user', user);\n    await next();\n});\n"],
  "mappings": "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",
  "names": []
}
