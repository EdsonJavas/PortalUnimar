import "./chunk-TW2XG35H.js";
import {
  getCookie
} from "./chunk-QCI3ID7K.js";
import "./chunk-UGBOKGPC.js";
import "./chunk-HKJ2B2AA.js";

// node_modules/hono/dist/helper/factory/index.js
var createMiddleware = (middleware) => middleware;

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/@getmocha/users-service/dist/backend.js
var DEFAULT_MOCHA_USERS_SERVICE_API_URL = "https://getmocha.com/u";
var MOCHA_SESSION_TOKEN_COOKIE_NAME = "mocha_session_token";
var SUPPORTED_OAUTH_PROVIDERS = ["google"];
async function getOAuthRedirectUrl(provider, options) {
  if (!SUPPORTED_OAUTH_PROVIDERS.includes(provider)) {
    throw new Error(`Unsupported OAuth provider: ${provider}`);
  }
  const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;
  const response = await fetch(`${apiUrl}/oauth/${provider}/redirect_url`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": options.apiKey
    }
  });
  if (!response.ok) {
    throw new Error(`Failed to get redirect URL for provider ${provider}: ${response.statusText}`);
  }
  const { redirect_url } = await response.json();
  return redirect_url;
}
async function exchangeCodeForSessionToken(code, options) {
  const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;
  const response = await fetch(`${apiUrl}/sessions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": options.apiKey
    },
    body: JSON.stringify({ code })
  });
  if (!response.ok) {
    throw new Error(`Failed to exchange code for session token: ${response.statusText}`);
  }
  const { session_token } = await response.json();
  return session_token;
}
async function getCurrentUser(sessionToken, options) {
  const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;
  try {
    const response = await fetch(`${apiUrl}/users/me`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${sessionToken}`,
        "x-api-key": options.apiKey
      }
    });
    if (!response.ok) {
      return null;
    }
    const { data: user } = await response.json();
    return user;
  } catch (error) {
    console.error("Error validating session:", error);
    return null;
  }
}
async function deleteSession(sessionToken, options) {
  const apiUrl = options.apiUrl || DEFAULT_MOCHA_USERS_SERVICE_API_URL;
  try {
    await fetch(`${apiUrl}/sessions`, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${sessionToken}`,
        "x-api-key": options.apiKey
      }
    });
  } catch (error) {
    console.error("Error deleting session:", error);
  }
}
var authMiddleware = createMiddleware(async (c, next) => {
  const sessionToken = getCookie(c, MOCHA_SESSION_TOKEN_COOKIE_NAME);
  if (typeof sessionToken !== "string") {
    return c.json({ error: "Unauthorized" }, 401);
  }
  const options = {
    apiUrl: c.env.MOCHA_USERS_SERVICE_API_URL,
    apiKey: c.env.MOCHA_USERS_SERVICE_API_KEY
  };
  const user = await getCurrentUser(sessionToken, options);
  if (!user) {
    throw new HTTPException(401, { message: "Invalid session token" });
  }
  c.set("user", user);
  await next();
});
export {
  DEFAULT_MOCHA_USERS_SERVICE_API_URL,
  MOCHA_SESSION_TOKEN_COOKIE_NAME,
  SUPPORTED_OAUTH_PROVIDERS,
  authMiddleware,
  deleteSession,
  exchangeCodeForSessionToken,
  getCurrentUser,
  getOAuthRedirectUrl
};
//# sourceMappingURL=@getmocha_users-service_backend.js.map
