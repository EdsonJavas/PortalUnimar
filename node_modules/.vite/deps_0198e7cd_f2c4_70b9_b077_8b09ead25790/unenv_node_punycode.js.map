{
  "version": 3,
  "sources": ["../../unenv/dist/runtime/node/internal/punycode/punycode.mjs", "../../unenv/dist/runtime/node/punycode.mjs"],
  "sourcesContent": ["// Source:\r\n// - https://unpkg.com/punycode@2.3.1/punycode.es6.js\r\n// - https://github.com/mathiasbynens/punycode.js/blob/v2.3.1/punycode.js\r\n/**\r\nCopyright Mathias Bynens <https://mathiasbynens.be/>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n/** Highest positive signed 32-bit float value */\r\nconst maxInt = 2147483647;\r\n/** Bootstring parameters */\r\nconst base = 36;\r\nconst tMin = 1;\r\nconst tMax = 26;\r\nconst skew = 38;\r\nconst damp = 700;\r\nconst initialBias = 72;\r\nconst initialN = 128;\r\nconst delimiter = \"-\";\r\n/** Regular expressions */\r\nconst regexPunycode = /^xn--/;\r\nconst regexNonASCII = /[^\\0-\\u007F]/;\r\nconst regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g;\r\n/** Error messages */\r\nconst errors = {\r\n\toverflow: \"Overflow: input needs wider integers to process\",\r\n\t\"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\r\n\t\"invalid-input\": \"Invalid input\"\r\n};\r\n/** Convenience shortcuts */\r\nconst baseMinusTMin = base - tMin;\r\nconst floor = Math.floor;\r\nconst stringFromCharCode = String.fromCharCode;\r\n/*--------------------------------------------------------------------------*/\r\n/**\r\n* A generic error utility function.\r\n* @private\r\n* @param {String} type The error type.\r\n* @returns {Error} Throws a `RangeError` with the applicable error message.\r\n*/\r\nfunction error(type) {\r\n\tthrow new RangeError(errors[type]);\r\n}\r\n/**\r\n* A generic `Array#map` utility function.\r\n* @private\r\n* @param {Array} array The array to iterate over.\r\n* @param {Function} callback The function that gets called for every array\r\n* item.\r\n* @returns {Array} A new array of values returned by the callback function.\r\n*/\r\nfunction map(array, callback) {\r\n\tconst result = [];\r\n\tlet length = array.length;\r\n\twhile (length--) {\r\n\t\tresult[length] = callback(array[length]);\r\n\t}\r\n\treturn result;\r\n}\r\n/**\r\n* A simple `Array#map`-like wrapper to work with domain name strings or email\r\n* addresses.\r\n* @private\r\n* @param {String} domain The domain name or email address.\r\n* @param {Function} callback The function that gets called for every\r\n* character.\r\n* @returns {String} A new string of characters returned by the callback\r\n* function.\r\n*/\r\nfunction mapDomain(domain, callback) {\r\n\tconst parts = domain.split(\"@\");\r\n\tlet result = \"\";\r\n\tif (parts.length > 1) {\r\n\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\tresult = parts[0] + \"@\";\r\n\t\tdomain = parts[1];\r\n\t}\r\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\tdomain = domain.replace(regexSeparators, \".\");\r\n\tconst labels = domain.split(\".\");\r\n\tconst encoded = map(labels, callback).join(\".\");\r\n\treturn result + encoded;\r\n}\r\n/**\r\n* Creates an array containing the numeric code points of each Unicode\r\n* character in the string. While JavaScript uses UCS-2 internally,\r\n* this function will convert a pair of surrogate halves (each of which\r\n* UCS-2 exposes as separate characters) into a single code point,\r\n* matching UTF-16.\r\n* @see `punycode.ucs2.encode`\r\n* @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n* @memberOf punycode.ucs2\r\n* @name decode\r\n* @param {String} string The Unicode input string (UCS-2).\r\n* @returns {Array} The new array of code points.\r\n*/\r\nfunction ucs2decode(string) {\r\n\tconst output = [];\r\n\tlet counter = 0;\r\n\tconst length = string.length;\r\n\twhile (counter < length) {\r\n\t\tconst value = string.charCodeAt(counter++);\r\n\t\tif (value >= 55296 && value <= 56319 && counter < length) {\r\n\t\t\t// It's a high surrogate, and there is a next character.\r\n\t\t\tconst extra = string.charCodeAt(counter++);\r\n\t\t\tif ((extra & 64512) == 56320) {\r\n\t\t\t\t// Low surrogate.\r\n\t\t\t\toutput.push(((value & 1023) << 10) + (extra & 1023) + 65536);\r\n\t\t\t} else {\r\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\r\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\r\n\t\t\t\toutput.push(value);\r\n\t\t\t\tcounter--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutput.push(value);\r\n\t\t}\r\n\t}\r\n\treturn output;\r\n}\r\n/**\r\n* Creates a string based on an array of numeric code points.\r\n* @see `punycode.ucs2.decode`\r\n* @memberOf punycode.ucs2\r\n* @name encode\r\n* @param {Array} codePoints The array of numeric code points.\r\n* @returns {String} The new Unicode string (UCS-2).\r\n*/\r\nconst ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);\r\n/**\r\n* Converts a basic code point into a digit/integer.\r\n* @see `digitToBasic()`\r\n* @private\r\n* @param {Number} codePoint The basic numeric code point value.\r\n* @returns {Number} The numeric value of a basic code point (for use in\r\n* representing integers) in the range `0` to `base - 1`, or `base` if\r\n* the code point does not represent a value.\r\n*/\r\nconst basicToDigit = function(codePoint) {\r\n\tif (codePoint >= 48 && codePoint < 58) {\r\n\t\treturn 26 + (codePoint - 48);\r\n\t}\r\n\tif (codePoint >= 65 && codePoint < 91) {\r\n\t\treturn codePoint - 65;\r\n\t}\r\n\tif (codePoint >= 97 && codePoint < 123) {\r\n\t\treturn codePoint - 97;\r\n\t}\r\n\treturn base;\r\n};\r\n/**\r\n* Converts a digit/integer into a basic code point.\r\n* @see `basicToDigit()`\r\n* @private\r\n* @param {Number} digit The numeric value of a basic code point.\r\n* @returns {Number} The basic code point whose value (when used for\r\n* representing integers) is `digit`, which needs to be in the range\r\n* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n* used; else, the lowercase form is used. The behavior is undefined\r\n* if `flag` is non-zero and `digit` has no uppercase form.\r\n*/\r\nconst digitToBasic = function(digit, flag) {\r\n\t//  0..25 map to ASCII a..z or A..Z\r\n\t// 26..35 map to ASCII 0..9\r\n\t// @ts-ignore\r\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n};\r\n/**\r\n* Bias adaptation function as per section 3.4 of RFC 3492.\r\n* https://tools.ietf.org/html/rfc3492#section-3.4\r\n* @private\r\n*/\r\nconst adapt = function(delta, numPoints, firstTime) {\r\n\tlet k = 0;\r\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\tdelta += floor(delta / numPoints);\r\n\tfor (; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\tdelta = floor(delta / baseMinusTMin);\r\n\t}\r\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n};\r\n/**\r\n* Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n* symbols.\r\n* @memberOf punycode\r\n* @param {String} input The Punycode string of ASCII-only symbols.\r\n* @returns {String} The resulting string of Unicode symbols.\r\n*/\r\nconst decode = function(input) {\r\n\t// Don't use UCS-2.\r\n\tconst output = [];\r\n\tconst inputLength = input.length;\r\n\tlet i = 0;\r\n\tlet n = initialN;\r\n\tlet bias = initialBias;\r\n\t// Handle the basic code points: let `basic` be the number of input code\r\n\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t// the first basic code points to the output.\r\n\tlet basic = input.lastIndexOf(delimiter);\r\n\tif (basic < 0) {\r\n\t\tbasic = 0;\r\n\t}\r\n\tfor (let j = 0; j < basic; ++j) {\r\n\t\t// if it's not a basic code point\r\n\t\tif (input.charCodeAt(j) >= 128) {\r\n\t\t\terror(\"not-basic\");\r\n\t\t}\r\n\t\toutput.push(input.charCodeAt(j));\r\n\t}\r\n\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t// points were copied; start at the beginning otherwise.\r\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\r\n\t\t// `index` is the index of the next character to be consumed.\r\n\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t// value at the end to obtain `delta`.\r\n\t\tconst oldi = i;\r\n\t\tfor (let w = 1, k = base;; k += base) {\r\n\t\t\tif (index >= inputLength) {\r\n\t\t\t\terror(\"invalid-input\");\r\n\t\t\t}\r\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\r\n\t\t\tif (digit >= base) {\r\n\t\t\t\terror(\"invalid-input\");\r\n\t\t\t}\r\n\t\t\tif (digit > floor((maxInt - i) / w)) {\r\n\t\t\t\terror(\"overflow\");\r\n\t\t\t}\r\n\t\t\ti += digit * w;\r\n\t\t\tconst t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\r\n\t\t\tif (digit < t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tconst baseMinusT = base - t;\r\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\terror(\"overflow\");\r\n\t\t\t}\r\n\t\t\tw *= baseMinusT;\r\n\t\t}\r\n\t\tconst out = output.length + 1;\r\n\t\tbias = adapt(i - oldi, out, oldi === 0);\r\n\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\terror(\"overflow\");\r\n\t\t}\r\n\t\tn += floor(i / out);\r\n\t\ti %= out;\r\n\t\t// Insert `n` at position `i` of the output.\r\n\t\toutput.splice(i++, 0, n);\r\n\t}\r\n\treturn String.fromCodePoint(...output);\r\n};\r\n/**\r\n* Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n* Punycode string of ASCII-only symbols.\r\n* @memberOf punycode\r\n* @param {String} input The string of Unicode symbols.\r\n* @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n*/\r\nconst encode = function(_input) {\r\n\tconst output = [];\r\n\t// Convert the input in UCS-2 to an array of Unicode code points.\r\n\tconst input = ucs2decode(_input);\r\n\t// Cache the length.\r\n\tconst inputLength = input.length;\r\n\t// Initialize the state.\r\n\tlet n = initialN;\r\n\tlet delta = 0;\r\n\tlet bias = initialBias;\r\n\t// Handle the basic code points.\r\n\tfor (const currentValue of input) {\r\n\t\tif (currentValue < 128) {\r\n\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t}\r\n\t}\r\n\tconst basicLength = output.length;\r\n\tlet handledCPCount = basicLength;\r\n\t// `handledCPCount` is the number of code points that have been handled;\r\n\t// `basicLength` is the number of basic code points.\r\n\t// Finish the basic string with a delimiter unless it's empty.\r\n\tif (basicLength) {\r\n\t\toutput.push(delimiter);\r\n\t}\r\n\t// Main encoding loop:\r\n\twhile (handledCPCount < inputLength) {\r\n\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t// larger one:\r\n\t\tlet m = maxInt;\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\tm = currentValue;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t// but guard against overflow.\r\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\r\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\terror(\"overflow\");\r\n\t\t}\r\n\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\tn = m;\r\n\t\tfor (const currentValue of input) {\r\n\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\terror(\"overflow\");\r\n\t\t\t}\r\n\t\t\tif (currentValue === n) {\r\n\t\t\t\t// Represent delta as a generalized variable-length integer.\r\n\t\t\t\tlet q = delta;\r\n\t\t\t\tfor (let k = base;; k += base) {\r\n\t\t\t\t\tconst t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\r\n\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst qMinusT = q - t;\r\n\t\t\t\t\tconst baseMinusT = base - t;\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\r\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t}\r\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\r\n\t\t\t\tdelta = 0;\r\n\t\t\t\t++handledCPCount;\r\n\t\t\t}\r\n\t\t}\r\n\t\t++delta;\r\n\t\t++n;\r\n\t}\r\n\treturn output.join(\"\");\r\n};\r\n/**\r\n* Converts a Punycode string representing a domain name or an email address\r\n* to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n* it doesn't matter if you call it on a string that has already been\r\n* converted to Unicode.\r\n* @memberOf punycode\r\n* @param {String} input The Punycoded domain name or email address to\r\n* convert to Unicode.\r\n* @returns {String} The Unicode representation of the given Punycode\r\n* string.\r\n*/\r\nconst toUnicode = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\r\n\t});\r\n};\r\n/**\r\n* Converts a Unicode string representing a domain name or an email address to\r\n* Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n* i.e. it doesn't matter if you call it with a domain that's already in\r\n* ASCII.\r\n* @memberOf punycode\r\n* @param {String} input The domain name or email address to convert, as a\r\n* Unicode string.\r\n* @returns {String} The Punycode representation of the given domain name or\r\n* email address.\r\n*/\r\nconst toASCII = function(input) {\r\n\treturn mapDomain(input, function(string) {\r\n\t\treturn regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\r\n\t});\r\n};\r\n/*--------------------------------------------------------------------------*/\r\n/**\r\n* A string representing the current Punycode.js version number.\r\n* @memberOf punycode\r\n* @type String\r\n*/\r\nconst version = \"2.3.1\";\r\n/**\r\n* An object of methods to convert from JavaScript's internal character\r\n* representation (UCS-2) to Unicode code points, and back.\r\n* @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n* @memberOf punycode\r\n* @type Object\r\n*/\r\nconst ucs2 = {\r\n\tdecode: ucs2decode,\r\n\tencode: ucs2encode\r\n};\r\n/** Define the public API */\r\nconst punycode = {\r\n\tversion,\r\n\tucs2,\r\n\tdecode,\r\n\tencode,\r\n\ttoASCII,\r\n\ttoUnicode\r\n};\r\nexport { version, ucs2, decode, encode, toASCII, toUnicode };\r\nexport default punycode;\r\n", "import _punycode from \"./internal/punycode/punycode.mjs\";\r\nexport * from \"./internal/punycode/punycode.mjs\";\r\nexport default _punycode;\r\n"],
  "mappings": ";;;AA0BA,IAAM,SAAS;AAEf,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,cAAc;AACpB,IAAM,WAAW;AACjB,IAAM,YAAY;AAElB,IAAM,gBAAgB;AACtB,IAAM,gBAAgB;AACtB,IAAM,kBAAkB;AAExB,IAAM,SAAS;AAAA,EACd,UAAU;AAAA,EACV,aAAa;AAAA,EACb,iBAAiB;AAClB;AAEA,IAAM,gBAAgB,OAAO;AAC7B,IAAM,QAAQ,KAAK;AACnB,IAAM,qBAAqB,OAAO;AAQlC,SAAS,MAAM,MAAM;AACpB,QAAM,IAAI,WAAW,OAAO,IAAI,CAAC;AAClC;AASA,SAAS,IAAI,OAAO,UAAU;AAC7B,QAAM,SAAS,CAAC;AAChB,MAAI,SAAS,MAAM;AACnB,SAAO,UAAU;AAChB,WAAO,MAAM,IAAI,SAAS,MAAM,MAAM,CAAC;AAAA,EACxC;AACA,SAAO;AACR;AAWA,SAAS,UAAU,QAAQ,UAAU;AACpC,QAAM,QAAQ,OAAO,MAAM,GAAG;AAC9B,MAAI,SAAS;AACb,MAAI,MAAM,SAAS,GAAG;AAGrB,aAAS,MAAM,CAAC,IAAI;AACpB,aAAS,MAAM,CAAC;AAAA,EACjB;AAEA,WAAS,OAAO,QAAQ,iBAAiB,GAAG;AAC5C,QAAM,SAAS,OAAO,MAAM,GAAG;AAC/B,QAAM,UAAU,IAAI,QAAQ,QAAQ,EAAE,KAAK,GAAG;AAC9C,SAAO,SAAS;AACjB;AAcA,SAAS,WAAW,QAAQ;AAC3B,QAAM,SAAS,CAAC;AAChB,MAAI,UAAU;AACd,QAAM,SAAS,OAAO;AACtB,SAAO,UAAU,QAAQ;AACxB,UAAM,QAAQ,OAAO,WAAW,SAAS;AACzC,QAAI,SAAS,SAAS,SAAS,SAAS,UAAU,QAAQ;AAEzD,YAAM,QAAQ,OAAO,WAAW,SAAS;AACzC,WAAK,QAAQ,UAAU,OAAO;AAE7B,eAAO,OAAO,QAAQ,SAAS,OAAO,QAAQ,QAAQ,KAAK;AAAA,MAC5D,OAAO;AAGN,eAAO,KAAK,KAAK;AACjB;AAAA,MACD;AAAA,IACD,OAAO;AACN,aAAO,KAAK,KAAK;AAAA,IAClB;AAAA,EACD;AACA,SAAO;AACR;AASA,IAAM,aAAa,CAAC,eAAe,OAAO,cAAc,GAAG,UAAU;AAUrE,IAAM,eAAe,SAAS,WAAW;AACxC,MAAI,aAAa,MAAM,YAAY,IAAI;AACtC,WAAO,MAAM,YAAY;AAAA,EAC1B;AACA,MAAI,aAAa,MAAM,YAAY,IAAI;AACtC,WAAO,YAAY;AAAA,EACpB;AACA,MAAI,aAAa,MAAM,YAAY,KAAK;AACvC,WAAO,YAAY;AAAA,EACpB;AACA,SAAO;AACR;AAYA,IAAM,eAAe,SAAS,OAAO,MAAM;AAI1C,SAAO,QAAQ,KAAK,MAAM,QAAQ,QAAQ,QAAQ,MAAM;AACzD;AAMA,IAAM,QAAQ,SAAS,OAAO,WAAW,WAAW;AACnD,MAAI,IAAI;AACR,UAAQ,YAAY,MAAM,QAAQ,IAAI,IAAI,SAAS;AACnD,WAAS,MAAM,QAAQ,SAAS;AAChC,SAAO,QAAQ,gBAAgB,QAAQ,GAAG,KAAK,MAAM;AACpD,YAAQ,MAAM,QAAQ,aAAa;AAAA,EACpC;AACA,SAAO,MAAM,KAAK,gBAAgB,KAAK,SAAS,QAAQ,KAAK;AAC9D;AAQA,IAAM,SAAS,SAAS,OAAO;AAE9B,QAAM,SAAS,CAAC;AAChB,QAAM,cAAc,MAAM;AAC1B,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,OAAO;AAIX,MAAI,QAAQ,MAAM,YAAY,SAAS;AACvC,MAAI,QAAQ,GAAG;AACd,YAAQ;AAAA,EACT;AACA,WAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAE/B,QAAI,MAAM,WAAW,CAAC,KAAK,KAAK;AAC/B,YAAM,WAAW;AAAA,IAClB;AACA,WAAO,KAAK,MAAM,WAAW,CAAC,CAAC;AAAA,EAChC;AAGA,WAAS,QAAQ,QAAQ,IAAI,QAAQ,IAAI,GAAG,QAAQ,eAAc;AAMjE,UAAM,OAAO;AACb,aAAS,IAAI,GAAG,IAAI,QAAO,KAAK,MAAM;AACrC,UAAI,SAAS,aAAa;AACzB,cAAM,eAAe;AAAA,MACtB;AACA,YAAM,QAAQ,aAAa,MAAM,WAAW,OAAO,CAAC;AACpD,UAAI,SAAS,MAAM;AAClB,cAAM,eAAe;AAAA,MACtB;AACA,UAAI,QAAQ,OAAO,SAAS,KAAK,CAAC,GAAG;AACpC,cAAM,UAAU;AAAA,MACjB;AACA,WAAK,QAAQ;AACb,YAAM,IAAI,KAAK,OAAO,OAAO,KAAK,OAAO,OAAO,OAAO,IAAI;AAC3D,UAAI,QAAQ,GAAG;AACd;AAAA,MACD;AACA,YAAM,aAAa,OAAO;AAC1B,UAAI,IAAI,MAAM,SAAS,UAAU,GAAG;AACnC,cAAM,UAAU;AAAA,MACjB;AACA,WAAK;AAAA,IACN;AACA,UAAM,MAAM,OAAO,SAAS;AAC5B,WAAO,MAAM,IAAI,MAAM,KAAK,SAAS,CAAC;AAGtC,QAAI,MAAM,IAAI,GAAG,IAAI,SAAS,GAAG;AAChC,YAAM,UAAU;AAAA,IACjB;AACA,SAAK,MAAM,IAAI,GAAG;AAClB,SAAK;AAEL,WAAO,OAAO,KAAK,GAAG,CAAC;AAAA,EACxB;AACA,SAAO,OAAO,cAAc,GAAG,MAAM;AACtC;AAQA,IAAM,SAAS,SAAS,QAAQ;AAC/B,QAAM,SAAS,CAAC;AAEhB,QAAM,QAAQ,WAAW,MAAM;AAE/B,QAAM,cAAc,MAAM;AAE1B,MAAI,IAAI;AACR,MAAI,QAAQ;AACZ,MAAI,OAAO;AAEX,aAAW,gBAAgB,OAAO;AACjC,QAAI,eAAe,KAAK;AACvB,aAAO,KAAK,mBAAmB,YAAY,CAAC;AAAA,IAC7C;AAAA,EACD;AACA,QAAM,cAAc,OAAO;AAC3B,MAAI,iBAAiB;AAIrB,MAAI,aAAa;AAChB,WAAO,KAAK,SAAS;AAAA,EACtB;AAEA,SAAO,iBAAiB,aAAa;AAGpC,QAAI,IAAI;AACR,eAAW,gBAAgB,OAAO;AACjC,UAAI,gBAAgB,KAAK,eAAe,GAAG;AAC1C,YAAI;AAAA,MACL;AAAA,IACD;AAGA,UAAM,wBAAwB,iBAAiB;AAC/C,QAAI,IAAI,IAAI,OAAO,SAAS,SAAS,qBAAqB,GAAG;AAC5D,YAAM,UAAU;AAAA,IACjB;AACA,cAAU,IAAI,KAAK;AACnB,QAAI;AACJ,eAAW,gBAAgB,OAAO;AACjC,UAAI,eAAe,KAAK,EAAE,QAAQ,QAAQ;AACzC,cAAM,UAAU;AAAA,MACjB;AACA,UAAI,iBAAiB,GAAG;AAEvB,YAAI,IAAI;AACR,iBAAS,IAAI,QAAO,KAAK,MAAM;AAC9B,gBAAM,IAAI,KAAK,OAAO,OAAO,KAAK,OAAO,OAAO,OAAO,IAAI;AAC3D,cAAI,IAAI,GAAG;AACV;AAAA,UACD;AACA,gBAAM,UAAU,IAAI;AACpB,gBAAM,aAAa,OAAO;AAC1B,iBAAO,KAAK,mBAAmB,aAAa,IAAI,UAAU,YAAY,CAAC,CAAC,CAAC;AACzE,cAAI,MAAM,UAAU,UAAU;AAAA,QAC/B;AACA,eAAO,KAAK,mBAAmB,aAAa,GAAG,CAAC,CAAC,CAAC;AAClD,eAAO,MAAM,OAAO,uBAAuB,mBAAmB,WAAW;AACzE,gBAAQ;AACR,UAAE;AAAA,MACH;AAAA,IACD;AACA,MAAE;AACF,MAAE;AAAA,EACH;AACA,SAAO,OAAO,KAAK,EAAE;AACtB;AAYA,IAAM,YAAY,SAAS,OAAO;AACjC,SAAO,UAAU,OAAO,SAAS,QAAQ;AACxC,WAAO,cAAc,KAAK,MAAM,IAAI,OAAO,OAAO,MAAM,CAAC,EAAE,YAAY,CAAC,IAAI;AAAA,EAC7E,CAAC;AACF;AAYA,IAAM,UAAU,SAAS,OAAO;AAC/B,SAAO,UAAU,OAAO,SAAS,QAAQ;AACxC,WAAO,cAAc,KAAK,MAAM,IAAI,SAAS,OAAO,MAAM,IAAI;AAAA,EAC/D,CAAC;AACF;AAOA,IAAM,UAAU;AAQhB,IAAM,OAAO;AAAA,EACZ,QAAQ;AAAA,EACR,QAAQ;AACT;AAEA,IAAM,WAAW;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAEA,IAAO,mBAAQ;;;ACvZf,IAAOA,oBAAQ;",
  "names": ["punycode_default"]
}
