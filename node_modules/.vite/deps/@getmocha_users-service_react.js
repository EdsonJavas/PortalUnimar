import {
  require_jsx_runtime
} from "./chunk-HJ3XIB4S.js";
import {
  __toESM,
  require_react
} from "./chunk-XV7VEYX3.js";

// node_modules/@getmocha/users-service/dist/react.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var AuthContext = (0, import_react.createContext)(null);
function AuthProvider({ children }) {
  const [user, setUser] = (0, import_react.useState)(null);
  const userRef = (0, import_react.useRef)(null);
  const exchangeRef = (0, import_react.useRef)(null);
  const [isPending, setIsPending] = (0, import_react.useState)(true);
  const [isFetching, setIsFetching] = (0, import_react.useState)(false);
  const fetchUser = (0, import_react.useCallback)(async () => {
    if (userRef.current)
      return userRef.current;
    userRef.current = (async () => {
      setIsFetching(true);
      try {
        const response = await fetch("/api/users/me");
        if (!response.ok) {
          throw new Error(`Failed to fetch user: API responded with HTTP status ${response.status}`);
        }
        const user2 = await response.json();
        setUser(user2);
      } catch (error) {
        throw error;
      } finally {
        setIsFetching(false);
        userRef.current = null;
      }
    })();
    return userRef.current;
  }, []);
  const logout = (0, import_react.useCallback)(async () => {
    try {
      setUser(null);
      await fetch("/api/logout");
    } catch (error) {
      console.error("Failed to logout:", error);
    }
  }, []);
  const redirectToLogin = (0, import_react.useCallback)(async () => {
    try {
      const response = await fetch("/api/oauth/google/redirect_url");
      if (!response.ok) {
        throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);
      }
      const { redirectUrl } = await response.json();
      window.location.href = redirectUrl;
    } catch (error) {
      console.error(error);
    }
  }, []);
  const exchangeCodeForSessionToken = (0, import_react.useCallback)(() => {
    if (exchangeRef.current)
      return exchangeRef.current;
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get("code");
    if (!code) {
      throw new Error("Cannot exchange code for session token: no code provided in the URL search params.");
    }
    exchangeRef.current = (async (code2) => {
      try {
        const response = await fetch("/api/sessions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ code: code2 })
        });
        if (!response.ok) {
          throw new Error(`Failed to exchange code for session token: API responded with HTTP status ${response.status}`);
        }
        await fetchUser();
      } catch (error) {
        console.error(error);
      } finally {
      }
    })(code);
    return exchangeRef.current;
  }, [fetchUser]);
  (0, import_react.useEffect)(() => {
    fetchUser().then(() => setIsPending(false), () => setIsPending(false));
  }, []);
  const contextValue = {
    user,
    isPending,
    isFetching,
    fetchUser,
    redirectToLogin,
    exchangeCodeForSessionToken,
    logout
  };
  return (0, import_jsx_runtime.jsx)(AuthContext.Provider, { value: contextValue, children });
}
function useAuth() {
  const context = (0, import_react.useContext)(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within a AuthProvider");
  }
  return context;
}
export {
  AuthProvider,
  useAuth
};
//# sourceMappingURL=@getmocha_users-service_react.js.map
