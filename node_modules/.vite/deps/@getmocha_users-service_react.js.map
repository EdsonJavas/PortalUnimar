{
  "version": 3,
  "sources": ["../../@getmocha/users-service/dist/react.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\r\nimport { createContext, useCallback, useContext, useEffect, useRef, useState } from 'react';\r\nconst AuthContext = createContext(null);\r\n/**\r\n * A React context provider that manages authentication state and related actions.\r\n * Install this at the top of the React component tree to provide authentication\r\n * and user management functionality. This is needed for the `useAuth` hook to work.\r\n *\r\n * This will always fetch the `user` object on mount.\r\n *\r\n * @example\r\n * import { AuthProvider } from '@getmocha/users-service/react';\r\n *\r\n * // React Router example\r\n * export default function App() {\r\n *   return (\r\n *     <AuthProvider>\r\n *       <Router>\r\n *         <Routes>\r\n *           <Route path=\"/\" element={<HomePage />} />\r\n *           <Route path=\"/auth/callback\" element={<AuthCallbackPage />} />\r\n *         </Routes>\r\n *       </Router>\r\n *     </AuthProvider>\r\n *   );\r\n * }\r\n */\r\nexport function AuthProvider({ children }) {\r\n    const [user, setUser] = useState(null);\r\n    // Use these to dedup requests. This is mostly for avoiding multiple\r\n    // calls from useEffects in dev, which could cause wonky behavior with\r\n    // the loading states or problems when exchanging code for session token.\r\n    const userRef = useRef(null);\r\n    const exchangeRef = useRef(null);\r\n    const [isPending, setIsPending] = useState(true);\r\n    const [isFetching, setIsFetching] = useState(false);\r\n    const fetchUser = useCallback(async () => {\r\n        if (userRef.current)\r\n            return userRef.current;\r\n        userRef.current = (async () => {\r\n            setIsFetching(true);\r\n            try {\r\n                const response = await fetch('/api/users/me');\r\n                if (!response.ok) {\r\n                    throw new Error(`Failed to fetch user: API responded with HTTP status ${response.status}`);\r\n                }\r\n                const user = await response.json();\r\n                setUser(user);\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n            finally {\r\n                setIsFetching(false);\r\n                userRef.current = null;\r\n            }\r\n        })();\r\n        return userRef.current;\r\n    }, []);\r\n    const logout = useCallback(async () => {\r\n        try {\r\n            setUser(null);\r\n            await fetch('/api/logout');\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to logout:', error);\r\n        }\r\n    }, []);\r\n    const redirectToLogin = useCallback(async () => {\r\n        try {\r\n            const response = await fetch('/api/oauth/google/redirect_url');\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);\r\n            }\r\n            const { redirectUrl } = await response.json();\r\n            window.location.href = redirectUrl;\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    }, []);\r\n    const exchangeCodeForSessionToken = useCallback(() => {\r\n        // Ensure we only exchange the code once. In dev, useEffect will run\r\n        // twice, so we need to reuse this promise to avoid multiple exchanges\r\n        // which would otherwise result in a failed request. The failed request\r\n        // sometimes causes the entire flow to break.\r\n        if (exchangeRef.current)\r\n            return exchangeRef.current;\r\n        const urlParams = new URLSearchParams(window.location.search);\r\n        const code = urlParams.get('code');\r\n        if (!code) {\r\n            throw new Error('Cannot exchange code for session token: no code provided in the URL search params.');\r\n        }\r\n        exchangeRef.current = (async (code) => {\r\n            try {\r\n                const response = await fetch('/api/sessions', {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                    },\r\n                    body: JSON.stringify({ code }),\r\n                });\r\n                if (!response.ok) {\r\n                    throw new Error(`Failed to exchange code for session token: API responded with HTTP status ${response.status}`);\r\n                }\r\n                // Refetch user after successful code exchange to populate user state\r\n                await fetchUser();\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n            finally {\r\n                // exchangeRef is not set back to null on purpose.\r\n                // We only expect it to run once per full page load.\r\n                // If it's called more than once, it's either useEffect\r\n                // on page load in dev or a bug.\r\n            }\r\n        })(code);\r\n        return exchangeRef.current;\r\n    }, [fetchUser]);\r\n    useEffect(() => {\r\n        fetchUser().then(() => setIsPending(false), () => setIsPending(false));\r\n    }, []);\r\n    const contextValue = {\r\n        user,\r\n        isPending,\r\n        isFetching,\r\n        fetchUser,\r\n        redirectToLogin,\r\n        exchangeCodeForSessionToken,\r\n        logout,\r\n    };\r\n    return _jsx(AuthContext.Provider, { value: contextValue, children: children });\r\n}\r\n/**\r\n * A React hook that provides the AuthContextValue.\r\n * @example\r\n * const { user } = useAuth();\r\n */\r\nexport function useAuth() {\r\n    const context = useContext(AuthContext);\r\n    if (!context) {\r\n        throw new Error('useAuth must be used within a AuthProvider');\r\n    }\r\n    return context;\r\n}\r\n"],
  "mappings": "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",
  "names": ["user", "code", "_jsx"]
}
